import Vapor
import Fluent
import FluentMySQLDriver

public struct ServerResult {
    var success: Bool
    var info: String
    var userModel: User? = nil
}

public class UserController {
    private func generateLoginCode() -> String {
        // dict is at /usr/share/dict/words
        let wordList = "/usr/share/dict/words"
        var loginCode = ""

        // generate login code
        do {
            // parse word list and convert to array
            let rawString = try String(contentsOfFile: wordList)
            var arrayOfWords = rawString.split(separator: "\n")

            // prevent insecure codes from being generated by removing short words
            arrayOfWords.removeAll(where: {$0.count < 4})

            // randomly choose 4 words
            for _ in stride(from: 0, to: 4, by: 1) {
                loginCode += arrayOfWords[Int.random(in:0..<arrayOfWords.count)] + " "
            }
            loginCode.removeLast()
            
        } catch {
            print(error)
        }
        
        return loginCode
    }

    public func createUser(req: Request, username: String) throws -> EventLoopFuture<ServerResult> {
        let isNameAvailable = try findModel(req: req, username: username)
        return isNameAvailable.map { possibleUser -> ServerResult in
            var resultInfo = "Username taken. Please choose another username."
            let asyncCheckPassed = possibleUser == nil
            if asyncCheckPassed {
                let loginCode = self.generateLoginCode()
                
                req.password.async.hash(loginCode).map { loginHash in
                    User(username: username, loginCode: loginHash).save(on: req.db) 
                }

                resultInfo = loginCode
            }
            
            return ServerResult(success: asyncCheckPassed, info: resultInfo)
        }
    }

    private func findModel(req: Request, username: String) throws -> EventLoopFuture<User?> {
        return User.query(on: req.db)
          .filter(\.$username == username)
          .first()
    }

    private func compareCodes(req: Request, plainText: String, hash: String) -> Bool {
        do {
            return try req.password.verify(plainText, created: hash)
        } catch {
            print(error)
            return false
        }
    }
    
    public func login(req: Request, username: String, loginCode: String) throws -> EventLoopFuture<ServerResult> {
        let user = try findModel(req: req, username: username)
        return user.map { userModel in
            if userModel == nil {
                return ServerResult(success: false, info: "User does not exist.")
            }
            let dbHash = userModel!.loginCode

            // If login is successful, ignore the error message and include user model
            // If login fails, use error message
            let result = self.compareCodes(req: req, plainText: loginCode, hash: dbHash!)
            return ServerResult(success: result, info: "Credentials are mismatched.", userModel: userModel!)
        }
    }

    func getTasks(req: Request, username: String) -> EventLoopFuture<String>? {
        do {
            let user = try findModel(req: req, username: username)
            return user.map { userModel in
                return userModel!.tasks!
            }
        } catch {
            print(error)
            return nil        }
    }
}
